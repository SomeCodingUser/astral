version: "3.9"

volumes:
  node-data: {}
  postgres_db: {}
  redis_db: {}
  caddy_config: {}
  caddy_data: {}

services:
  # Caddy Reverse Proxy with CORS enabled
  caddy:
    ulimits:
      nofile:
        soft: 65536 # Soft limit for open files (WebSocket connections count)
        hard: 65536 # Hard limit for open files
    image: caddy:latest
    ports:
      - "80:9944" # Map external 80 to Caddy's 9944 for Node/RPC
      - "443:9944" # Map external 443 to Caddy's 9945 for HTTPS
      - "8081:8080" # Map external 8081 to Caddy's 8080 for Hasura
      - "3011:3001" # Map external 3011 to Caddy's 3001 for Consensus
      - "3012:3002" # Map external 3012 to Caddy's 3002 for Leaderboard
      - "3013:3003" # Map external 3013 to Caddy's 3003 for Staking
    volumes:
      - ./indexers/Caddyfile:/etc/caddy/Caddyfile # Mount the Caddyfile
      - caddy_data:/data # Volume for Let's Encrypt certificates
      - caddy_config:/config

    environment:
      - DOMAIN=subql.${NETWORK_ID}.subspace.network
    depends_on:
      - node
    restart: unless-stopped

  # Subspace Node
  node:
    image: ghcr.io/autonomys/node:${NODE_DOCKER_TAG}
    platform: linux/amd64
    volumes:
      - node-data:/var/subspace:rw
    ports:
      - "30333:30333/tcp"
      - "30433:30433/tcp"
    restart: unless-stopped
    command:
      [
        "run",
        "--chain",
        "${NETWORK_ID}",
        "--base-path",
        "/var/subspace",
        "--pot-external-entropy",
        "00000000000000000000661e88ab45dc3b61daec5ccf3cc83532153589b133b9",
        "--listen-on",
        "/ip4/0.0.0.0/tcp/30333",
        "--dsn-listen-on",
        "/ip4/0.0.0.0/tcp/30433",
        "--rpc-cors",
        "all",
        "--rpc-methods",
        "unsafe",
        "--rpc-listen-on",
        "0.0.0.0:9944",
        "--rpc-max-subscriptions-per-connection",
        "1000",
        "--rpc-max-connections",
        "20000",
        "--farmer",
        "--name",
        "astral",
        "--sync",
        "full",
      ]
    healthcheck:
      timeout: 5s
      interval: 30s
      retries: 60

  # Postgres Database
  postgres:
    image: postgres:16-alpine
    volumes:
      - postgres_db:/var/lib/postgresql/data
      - ./indexers/db/docker-entrypoint-initdb.d/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    restart: unless-stopped
    hostname: postgres
    environment:
      POSTGRES_DB: ${DB_DATABASE}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_MAX_CONNECTIONS: 500
    ports:
      - "${DB_PORT}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Hasura GraphQL Engine
  hasura:
    image: hasura/graphql-engine:v2.40.0
    depends_on:
      - "postgres"
    volumes:
      - ./indexers/db/migrations:/hasura-migrations
      - ./indexers/db/metadata:/hasura-metadata
    restart: unless-stopped
    environment:
      # Essential Environment Variables
      HASURA_GRAPHQL_METADATA_DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_DATABASE}
      HASURA_GRAPHQL_DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_DATABASE} # Main database connection
      HASURA_GRAPHQL_ADMIN_SECRET: ${HASURA_GRAPHQL_ADMIN_SECRET} # Admin access secret
      HASURA_GRAPHQL_JWT_SECRET: ${HASURA_GRAPHQL_JWT_SECRET} # JWT authentication secret

      # Console and Development Mode
      HASURA_GRAPHQL_ENABLE_CONSOLE: ${HASURA_GRAPHQL_ENABLE_CONSOLE} # Disable console in production
      HASURA_GRAPHQL_DEV_MODE: "true" # Disable development mode features

      # Role and CORS Settings
      HASURA_GRAPHQL_UNAUTHORIZED_ROLE: user # Default role for unauthenticated users
      HASURA_GRAPHQL_CORS_DOMAIN: ${HASURA_GRAPHQL_CORS_DOMAIN} # Allowed domains for CORS
      HASURA_GRAPHQL_STRINGIFY_NUMERIC_TYPES: "true"

      # Performance and Connection Settings
      HASURA_GRAPHQL_MAX_CONNECTIONS: 100 # Maximum number of database connections
      HASURA_GRAPHQL_STRIPES: 2 # Number of connection pool stripes
      HASURA_GRAPHQL_CONNECTIONS_PER_STRIPE: 50 # Connections per stripe
      HASURA_GRAPHQL_IDLE_TIMEOUT: 180 # Idle connection timeout in seconds
      HASURA_GRAPHQL_TIMEOUT: 60 # Request timeout in seconds

      # Logging Settings
      HASURA_GRAPHQL_LOG_LEVEL: "warn" # Log verbosity level
      HASURA_GRAPHQL_ENABLED_LOG_TYPES: "startup,http-log,webhook-log,websocket-log,query-log" # Enabled log types

      # Security and Authorization
      HASURA_GRAPHQL_ENABLE_ALLOWLIST: "false" # Disable query allowlisting

      # Hasura Migrations and Metadata
      HASURA_GRAPHQL_MIGRATIONS_DIR: /hasura-migrations
      HASURA_GRAPHQL_METADATA_DIR: /hasura-metadata

      # Task Board Action Endpoint
      HASURA_GRAPHQL_ACTION_TASK_BOARD: http://taskboard:${BULL_PORT}
    ports:
      - "${HASURA_GRAPHQL_PORT}:8080"
    command:
      - graphql-engine
      - serve

  dictionary_subquery_node:
    profiles: [dictionary, indexers]
    build:
      context: ./indexers/dictionary/${DICTIONARY_DIRECTORY}
    depends_on:
      "postgres":
        condition: service_healthy
    restart: unless-stopped
    environment:
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASSWORD}
      DB_DATABASE: ${DB_DATABASE}
      DB_HOST: ${DB_HOST}
      DB_PORT: 5432
    volumes:
      - ./indexers/dictionary/${DICTIONARY_DIRECTORY}:/dictionary
    healthcheck:
      test: ["CMD", "curl", "-f", "http://dictionary_subquery_node:3000/ready"]
      interval: 3s
      timeout: 5s
      retries: 10
    command:
      - -f=/dictionary
      - --disable-historical=true

  dictionary_graphql_engine:
    profiles: [dictionary, indexers]
    image: onfinality/subql-query:latest
    ports:
      - "${DICTIONARY_SUBQUERY_NODE_PORT}:3000"
    depends_on:
      - "postgres"
      - "dictionary_subquery_node"
    restart: unless-stopped
    environment:
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASSWORD}
      DB_DATABASE: ${DB_DATABASE}
      DB_HOST: ${DB_HOST}
      DB_PORT: 5432
    command:
      - --name=dictionary
      - --playground

  # Indexers Subquery Nodes
  consensus_subquery_node:
    profiles: [indexers]
    image: subquerynetwork/subql-node-substrate:latest
    ports:
      - "3001:3000"
    depends_on:
      "postgres":
        condition: service_healthy
      "dictionary_subquery_node":
        condition: service_healthy
    restart: unless-stopped
    environment:
      ENDPOINT: ${RPC_URLS}
      CHAIN_ID: ${CHAIN_ID}
      DICTIONARY: http://dictionary_subquery_node:3000
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASSWORD}
      DB_DATABASE: ${DB_DATABASE}
      DB_HOST: ${DB_HOST}
      DB_PORT: 5432
    volumes:
      - ./indexers/${NETWORK_ID}/consensus:/${NETWORK_ID}/consensus
    command:
      - ${SUB_COMMAND:-} # set SUB_COMMAND env variable to "test" to run tests
      - -f=/${NETWORK_ID}/consensus
      - --db-schema=consensus
      - --workers=4
      - --unsafe
      - --batch-size=250
      - --unfinalized-blocks=true
      - --disable-historical=false
    healthcheck:
      test: ["CMD", "curl", "-f", "http://consensus_subquery_node:3000/ready"]
      interval: 3s
      timeout: 5s
      retries: 10

  leaderboard_subquery_node:
    profiles: [indexers]
    image: subquerynetwork/subql-node-substrate:latest
    ports:
      - "3002:3000"
    depends_on:
      "postgres":
        condition: service_healthy
      "dictionary_subquery_node":
        condition: service_healthy
    restart: unless-stopped
    environment:
      ENDPOINT: ${RPC_URLS}
      CHAIN_ID: ${CHAIN_ID}
      DICTIONARY: http://dictionary_subquery_node:3000
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASSWORD}
      DB_DATABASE: ${DB_DATABASE}
      DB_HOST: ${DB_HOST}
      DB_PORT: 5432
    volumes:
      - ./indexers/${NETWORK_ID}/leaderboard:/${NETWORK_ID}/leaderboard
    command:
      - ${SUB_COMMAND:-} # set SUB_COMMAND env variable to "test" to run tests
      - -f=/${NETWORK_ID}/leaderboard
      - --db-schema=leaderboard
      - --workers=1
      - --unsafe
      - --batch-size=15
      - --disable-historical=true
    healthcheck:
      test: ["CMD", "curl", "-f", "http://leaderboard_subquery_node:3000/ready"]
      interval: 3s
      timeout: 5s
      retries: 10

  staking_subquery_node:
    profiles: [indexers]
    image: subquerynetwork/subql-node-substrate:latest
    ports:
      - "3003:3000"
    depends_on:
      "postgres":
        condition: service_healthy
      "dictionary_subquery_node":
        condition: service_healthy
    restart: unless-stopped
    environment:
      ENDPOINT: ${RPC_URLS}
      CHAIN_ID: ${CHAIN_ID}
      DICTIONARY: http://dictionary_subquery_node:3000
      DB_USER: ${DB_USER}
      DB_PASS: ${DB_PASSWORD}
      DB_DATABASE: ${DB_DATABASE}
      DB_HOST: ${DB_HOST}
      DB_PORT: 5432
    volumes:
      - ./indexers/${NETWORK_ID}/staking:/${NETWORK_ID}/staking
    command:
      - ${SUB_COMMAND:-} # set SUB_COMMAND env variable to "test" to run tests
      - -f=/${NETWORK_ID}/staking
      - --db-schema=staking
      - --workers=1
      - --unsafe
      - --batch-size=15
      - --disable-historical=true
    healthcheck:
      test: ["CMD", "curl", "-f", "http://staking_subquery_node:3000/ready"]
      interval: 3s
      timeout: 5s
      retries: 10

  # Redis
  redis:
    profiles: [task]
    image: redis:latest
    restart: unless-stopped
    ports:
      - "${REDIS_PORT}:6379"
    volumes:
      - redis_db:/data
    hostname: redis
    command: ["redis-server", "--bind", "0.0.0.0", "--port", "6379"]
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "redis-cli -h localhost -p 6379 ping | grep PONG || exit 1",
        ]
      interval: 5s
      timeout: 5s
      retries: 10

  # Express + BullMQ
  taskboard:
    profiles: [task]
    build:
      context: ./indexers/taskboard
    depends_on:
      redis:
        condition: service_healthy
    volumes:
      - ./indexers/taskboard:/app
    hostname: taskboard
    restart: unless-stopped
    ports:
      - "${BULL_PORT}:${BULL_PORT}"
    environment:
      BULL_USERNAME: ${BULL_USERNAME}
      BULL_PASSWORD: ${BULL_PASSWORD}
      BULL_PORT: ${BULL_PORT}
      BULL_SESSION_SECRET: ${BULL_SESSION_SECRET}

      REDIS_HOST: redis
      REDIS_PORT: ${REDIS_PORT}

      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_DATABASE: ${DB_DATABASE}
      DB_HOST: ${DB_HOST}
      DB_PORT: ${DB_PORT}

      NETWORK_ID: ${NETWORK_ID}

      SLACK_TOKEN: ${SLACK_TOKEN}
      SLACK_CONVERSATION_ID: ${SLACK_CONVERSATION_ID}
